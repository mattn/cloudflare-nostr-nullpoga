"use strict";

import {
    Event,
    getEventHash,
    getPublicKey,
    nip19,
    relayInit,
    signEvent,
} from "nostr-tools";

import { Ai } from "@cloudflare/ai";

let suddendeath = require("suddendeath");
let eaw = require("eastasianwidth");
let runes = require("runes");

export interface Env {
    NULLPOGA_GA_TOKEN: string;
    NULLPOGA_VA_TOKEN: string;
    NULLPOGA_LOGINBONUS_TOKEN: string;
    NULLPOGA_NSEC: string;
    ochinchinland: KVNamespace;
    nostr_relationship: KVNamespace;
    AI: any;
}

const NULLPOGA_NPUB =
    "4e86cdbb1ed747ff40c65303d1fc463e10aecb113049b05fc4317c29e31ccaaf";

const page = `
<!doctype html>
<link href="//fonts.bunny.net/css?family=sigmar-one:400" rel="stylesheet" />
<meta charset="utf-8" />
<title>Cloudflare NullpoGa</title>
<style>
body {
  font-size: 40px;
  text-align: center;
}
h1,h2,h3 {
  font-family: 'Sigmar One', serif;
  font-style: normal;
  text-shadow: none;
  text-decoration: none;
  text-transform: none;
  letter-spacing: -0.05em;
  word-spacing: 0em;
  line-height: 1.15;
}
</style>
<body>
	<h1>„Å¨„Çã„ÅΩ„ÉªÔΩ∂ÔæûÔΩØ</h1>
	2023 (C) <a href="http://mattn.kaoriya.net/">mattn</a>, code is <a href="https://github.com/mattn/cloudflare-nostr-nullpoga">here</a>
</body>
`;

function notAuthenticated(_request: Request, _env: Env) {
    return new Response(
        "Not Authenticated",
        {
            status: 401,
            headers: {
                "content-type": "text/plain; charset=UTF-8",
                "accept-charset": "utf-8",
            },
        },
    );
}

function notFound(_request: Request, _env: Env) {
    return new Response(`Not found`, {
        status: 404,
    });
}

function unsupportedMethod(_request: Request, _env: Env) {
    return new Response(`Unsupported method`, {
        status: 400,
    });
}

function bearerAuthentication(request: Request, secret: string) {
    if (!request.headers.has("authorization")) {
        return false;
    }
    const authorization = request.headers.get("Authorization")!;
    const [scheme, encoded] = authorization.split(" ");
    return scheme === "Bearer" && encoded === secret;
}

function createLike(env: Env, mention: Event): Event {
    const decoded = nip19.decode(env.NULLPOGA_NSEC);
    const sk = decoded.data as string;
    const pk = getPublicKey(sk);
    const created_at = mention.created_at + 1;
    let event = {
        id: "",
        kind: 7,
        pubkey: pk,
        created_at: created_at, // Math.floor(Date.now() / 1000),
        tags: [["e", mention.id]],
        content: "ü©∑",
        sig: "",
    };
    event.id = getEventHash(event);
    event.sig = signEvent(event, sk);
    return event;
}

function createReplyWithTags(
    env: Env,
    mention: Event,
    message: string,
    tags: string[][],
): Event {
    const decoded = nip19.decode(env.NULLPOGA_NSEC);
    const sk = decoded.data as string;
    const pk = getPublicKey(sk);
    if (mention.pubkey === pk) throw new Error("Self reply not acceptable");
    const tt = [];
    tt.push(["e", mention.id], ["p", mention.pubkey]);
    if (mention.kind === 42) {
        for (let tag of mention.tags.filter((x: any[]) => x[0] === "e")) {
            tt.push(tag);
        }
    }
    for (let tag of tags) {
        tt.push(tag);
    }
    const created_at = mention.created_at + 1;
    let event = {
        id: "",
        kind: mention.kind,
        pubkey: pk,
        created_at: created_at, // Math.floor(Date.now() / 1000),
        tags: tt,
        content: message,
        sig: "",
    };
    event.id = getEventHash(event);
    event.sig = signEvent(event, sk);
    return event;
}

function createNoteWithTags(
    env: Env,
    mention: Event,
    message: string,
    tags: string[][],
): Event {
    const decoded = nip19.decode(env.NULLPOGA_NSEC);
    const sk = decoded.data as string;
    const pk = getPublicKey(sk);
    const tt = [];
    if (mention.kind === 42) {
        for (let tag of mention.tags.filter((x: any[]) => x[0] === "e")) {
            tt.push(tag);
        }
    }
    for (let tag of tags) {
        tt.push(tag);
    }
    const created_at = mention.created_at + 1;
    let event = {
        id: "",
        kind: mention.kind,
        pubkey: pk,
        created_at: created_at, // Math.floor(Date.now() / 1000),
        tags: tt,
        content: message,
        sig: "",
    };
    event.id = getEventHash(event);
    event.sig = signEvent(event, sk);
    return event;
}

function JSONResponse(value: any): Response {
    if (value === null) return new Response("");
    return new Response(JSON.stringify(value), {
        headers: {
            "access-control-allow-origin": "*",
            "content-type": "application/json; charset=UTF-8",
        },
    });
}

async function doPage(_request: Request, _env: Env): Promise<Response> {
    return new Response(page, {
        headers: {
            "content-type": "text/html; charset=UTF-8",
        },
    });
}

type Relation = {
    follow: Event;
    mute: Event;
    time: number;
};

async function doRelationsihp(request: Request, env: Env): Promise<Response> {
    const { pathname } = new URL(request.url);
    const pathArray = pathname.split("/");
    let relation = JSON.parse(
        (await env.nostr_relationship.get(pathArray[2])) as string,
    ) as Relation | null;
    if (pathArray.length < 3) {
        return notFound(request, env);
    }
    if (relation === null || Date.now() - relation.time > 1800000) {
        const relay = relayInit("wss://yabu.me");
        await relay.connect();
        const sk = pathArray[2].startsWith("npub1")
            ? nip19.decode(pathArray[2]).data as string
            : pathArray[2];
        const follow = await relay.get({
            kinds: [3],
            authors: [sk],
        });
        if (follow === null) {
            return notFound(request, env);
        }
        const mute = await relay.get({
            kinds: [10000],
            authors: [sk],
        });
        if (mute === null) throw "Not Found";
        relation = {
            follow: follow,
            mute: mute,
            time: Date.now(),
        };
        await env.nostr_relationship.put(pathArray[2], JSON.stringify(relation));
    }
    if (pathArray.length === 3) {
        return JSONResponse(relation);
    }
    if (pathArray.length === 5) {
        const sk = pathArray[3].startsWith("npub1")
            ? nip19.decode(pathArray[3]).data as string
            : pathArray[3];
        switch (pathArray[4]) {
            case "follow":
                const followed = relation.follow.tags.filter((x: any[]) =>
                    x[0] === "p" && x[1] === sk
                ).length > 0;
                return JSONResponse(followed);
            case "mute":
                const muted = relation.mute.tags.filter((x: any[]) =>
                    x[0] === "p" && x[1] === sk
                ).length > 0;
                return JSONResponse(muted)
        }
    }
    return notFound(request, env);
}

async function doNullpo(request: Request, env: Env): Promise<Response> {
    if (!bearerAuthentication(request, env.NULLPOGA_GA_TOKEN)) {
        return notAuthenticated(request, env);
    }
    const mention: Event = await request.json();
    return JSONResponse(createNoteWithTags(env, mention, "„Å¨„Çã„ÅΩ", []))
}

async function doClock(_request: Request, env: Env): Promise<Response> {
    const now = new Date(
        Date.now() + ((new Date().getTimezoneOffset() + (9 * 60)) * 60 * 1000),
    );
    const hour = now.getHours();
    const message = "„Å¨„Çã„ÅΩ„Åå" + (hour < 12 ? "ÂçàÂâç" : "ÂçàÂæå") + (hour % 12) +
        "ÊôÇ„Çí„Åä‰ºù„Åà„Åó„Åæ„Åô";
    const mention = {
        kind: 1,
        tags: [],
        pubkey: "",
        id: "",
        sig: "",
        content: "",
        created_at: Math.floor(Date.now() / 1000),
    } as Event;
    return JSONResponse(createNoteWithTags(env, mention, message, []))
}

async function doOchinchinLandStatus(
    _request: Request,
    env: Env,
): Promise<Response> {
    const status = (await env.ochinchinland.get("status")) as string;
    return JSONResponse({ "status": status })
}

async function doSuitou(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    return JSONResponse(createReplyWithTags(env, mention, "„Åà„Çâ„ÅÑÔºÅ", []))
}

async function doIgyo(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    let tags = [[
        "emoji",
        "igyo",
        "https://i.gyazo.com/6ca054b84392b4b1bd0038d305f72b64.png",
    ]];
    return JSONResponse(createReplyWithTags(env, mention, ":igyo:", tags))
}

async function doLetterpack(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    return JSONResponse(createReplyWithTags(
        env,
        mention,
        "https://i.gyazo.com/d3d5ab0007253e060482e52e5734d402.png",
        [],
    ))
}

async function doUltrasoul(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    return JSONResponse(createReplyWithTags(env, mention, "ÔΩ≥ÔæôÔæÑÔæóÔΩøÔΩ©!", []))
}

async function doAngel(request: Request, env: Env): Promise<Response> {
    const content = "ÔººÔΩ¥ÔΩ∞ÔæùÔΩºÔæûÔΩ™ÔΩ∞Ôæô!üôåÔºè'";
    const mention: Event = await request.json();
    return JSONResponse(createNoteWithTags(env, mention, content, []))
}

async function doHi(request: Request, env: Env): Promise<Response> {
    const content = "ÔººÔæäÔΩ∞ÔΩ≤!üôåÔºè'";
    const mention: Event = await request.json();
    return JSONResponse(createNoteWithTags(env, mention, content, []))
}

export interface bookmark {
    pattern: RegExp;
    site: string;
}

const bookmarks: bookmark[] = [
    {
        pattern: /^(„Åä„ÅÑ„Åè„Çâsats|„Åä„ÅÑ„Åè„Çâ„Çµ„ÉÉ„ÉÑ)$/i,
        site: "https://lokuyow.github.io/sats-rate/",
    },
    {
        pattern: /^(„Å∂„Åè„Åæ„Å≥„ÅÖ„ÅÇ|„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ)/i,
        site: "https://nostr-bookmark-viewer3.vercel.app/",
    },
    { pattern: /^(nostrends|„Éà„É¨„É≥„Éâ)/i, site: "https://nostrends.vercel.app/" },
    { pattern: /^(nostrbuzzs|buzz|„Éê„Ç∫)/i, site: "https://nostrbuzzs.deno.dev/" },
    {
        pattern:
            /^(nosli|„ÅÆ„Åô„Çä|„Åã„Åæ„Åè„Çâ„Åï„Çì„ÅÆ„Ç¢„É¨|ÈéåÂÄâ„Åï„Çì„ÅÆ„Ç¢„É¨|togetter„Åø„Åü„ÅÑ„Å™„ÇÑ„Å§|togetter„Åø„Åü„ÅÑ„Å™Â•¥)$/i,
        site: "https://nosli.vercel.app/",
    },
    {
        pattern: /^(„ÅÆ„Åû„ÅçÁ™ì|„ÅÆ„Åû„Åç„Åæ„Å©)$/i,
        site: "https://relay-jp.nostr.wirednet.jp/index.html",
    },
    { pattern: /^(Ê§úÁ¥¢„Éù„Éº„Çø„É´)$/i, site: "https://nostr.hoku.in/" },
    {
        pattern: /^(Ê§úÁ¥¢)/i,
        site:
            "https://nosey.vercel.app (ÈéåÂÄâ)\nhttps://search.yabu.me („ÅÑ„Åè„Çâ„Å©„Çì)\nhttps://showhyuga.pages.dev/utility/nos_search („Å≤„ÇÖ„ÅÜ„Åå)\nhttps://nos.today/ („Å†„Çâ„Åó)",
    },
    {
        pattern: /^(nostrflu|„Éï„Ç©„É≠„Éº„É™„Çπ„Éà.*ÂÜçÈÄÅ‰ø°)/i,
        site: "https://heguro.github.io/nostr-following-list-util/",
    },
    { pattern: /^(nostter|„ÅÆ„Åô„Å£„Åü„Éº)$/i, site: "https://nostter.vercel.app/" },
    { pattern: /^(rabbit)$/i, site: "https://syusui-s.github.io/rabbit/" },
    { pattern: /^(ÁµµÊñáÂ≠ó)$/i, site: "https://emojis-iota.vercel.app/" },
    {
        pattern: /^(„Ç§„Éô„É≥„Éà„ÉÅ„Çß„ÉÉ„Ç´„Éº|„ÉÅ„Çß„ÉÉ„Ç´„Éº)$/i,
        site: "https://koteitan.github.io/nostr-post-checker/",
    },
    {
        pattern: /^(„Ç§„Éô„É≥„ÉàÂâäÈô§|ÂâäÈô§)$/i,
        site: "https://nostr-delete.vercel.app/",
    },
    {
        pattern: /^(ÈáéÈ†àÁî∞|ÊµÅÈÄü|Ë¶≥Ê∏¨ÊâÄ|ÈáéÈ†àÁî∞Â∑ùË¶≥Ê∏¨ÊâÄ|ÈáéÊ¥≤Áî∞Â∑ùÂÆöÁÇπË¶≥Ê∏¨ÊâÄ)$/i,
        site: "https://nostr-hotter-site.vercel.app/",
    },
    {
        pattern: /^(„ÅÆ„Åï„Çâ„ÅÑ|„Åä„Åï„Çâ„ÅÑ|„Åü„ÅÑ„ÇÄ„Åæ„Åó„Çì|„Åã„Åô„Å¶„Çâ„Åµ„ÅÉ„Åï„Çì„ÅÆ„Ç¢„É¨)$/i,
        site: "https://nosaray.vercel.app/",
    },
    { pattern: /^(„Çπ„ÉÜ„Éº„Çø„Çπ)$/i, site: "https://nostatus.vercel.app/" },
    { pattern: /^(‰ΩçÁΩÆ„ÅÆÁ¥π‰ªã|‰ΩçÁΩÆË°®Á§∫)$/i, site: "https://mapnos.vercel.app/" },
    {
        pattern: /^(‰ΩçÁΩÆ„ÅÆÊõ¥Êñ∞)$/i,
        site: "https://penpenpng.github.io/imhere-nostr/",
    },
    {
        pattern: /^(MATTN)$/,
        site:
            "https://polygonscan.com/token/0xc8f48e2b873111aa820463915b3a637302171d61",
    },
    {
        pattern: /^„Ç¢„Éâ„Éô„É≥„Éà„Ç´„É¨„É≥„ÉÄ„Éº$/,
        site:
            "Nostr (1) https://adventar.org/calendars/8794\nNostr (2) https://adventar.org/calendars/8880\nBlueSky https://adventar.org/calendars/9443",
    },
];

async function doWhere(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    let content = "" + mention.content.replace(/„Å©„Åì[?Ôºü]*$/, "").trim();
    for (const b of bookmarks) {
        if (content.match(b.pattern)) {
            return JSONResponse(createReplyWithTags(env, mention, b.site, []))
        }
    }
    const mNIP = content.match(/^NIP-?([0-9]+)/i)
    if (mNIP) {
        const url = "https://github.com/nostr-protocol/nips/blob/master/" + mNIP[1] + ".md";
        const res = await fetch(url);
        if (res.ok) {
            return JSONResponse(createReplyWithTags(env, mention, url, []))
        }
        return JSONResponse(createReplyWithTags(env, mention, "„Åù„Çì„Å™„ÇìÁÑ°„ÅÑ", []))
    }
    const mKIND = content.match(/^KIND ([0-9]+)/i)
    if (mKIND) {
        const url = "https://raw.githubusercontent.com/nostr-protocol/nips/master/README.md"
        const res = await fetch(url);
        if (res.ok) {
            const m = new Map<number, string>();
            (await res.text()).split(/\n## Event Kinds/)[1].split(/\n\n/)[0].split(/\n/).forEach(x => {
                const tok = x.split(/\|/)
                if (tok.length < 4) return
                const kind = tok[1].replace(/[`` ]/g, "") || ""
                if (kind === "") return
                const page = tok[3].match(/\(([0-9]+\.md)\)/)?.[1] || ""
                if (page === "") return
                m.set(Number(kind), page)
            })
            const kind = Number(mKIND[1])
            if (m.has(kind)) {
                const url = "https://github.com/nostr-protocol/nips/blob/master/" + m.get(kind)
                return JSONResponse(createReplyWithTags(env, mention, url, []))
            }
        }
        return JSONResponse(createReplyWithTags(env, mention, "„Åù„Çì„Å™„ÇìÁÑ°„ÅÑ", []))
    }
    return JSONResponse(null);
}

async function doGoogle(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const m = mention.content.match(/^\[(.+)\]\[Ê§úÁ¥¢\]$/) ||
        mention.content.match(/^Ê§úÁ¥¢:(.+)$/) || [];
    const contents = "https://www.google.com/search?q=" +
        encodeURIComponent((m ? m[1] : "").trim());
    return JSONResponse(createReplyWithTags(env, mention, contents, []))
}

async function doOnlyYou(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");
    let content = mention.content.trim();
    content = content
        .replace(/^„Åø„Çì„Å™(?:\s*)(.*)(?:\s*)„Å¶„Çã[?Ôºü!ÔºÅ.]*$/s, "$1„Å¶„Å™„ÅÑ„ÅÆ„ÅäÂâç„Å†„Åë")
        .replace(/^„Åø„Çì„Å™(?:\s*)(.*)(?:\s*)„Åß„Çã[?Ôºü!ÔºÅ.]*$/s, "$1„Åß„Å™„ÅÑ„ÅÆ„ÅäÂâç„Å†„Åë")
        .replace(/^„Åø„Çì„Å™(?:\s*)(.*)(?:\s*)„ÅÑ„Çã[?Ôºü!ÔºÅ.]*$/s, "$1„ÅÑ„Å™„ÅÑ„ÅÆ„ÅäÂâç„Å†„Åë")
        .replace(/^„Åø„Çì„Å™(?:\s*)(.*)(?:\s*)„Å¶„Å™„ÅÑ[?Ôºü!ÔºÅ.]*$/s, "$1„Å¶„Çã„ÅÆ„ÅäÂâç„Å†„Åë")
        .replace(/^„Åø„Çì„Å™(?:\s*)(.*)(?:\s*)„Åß„Å™„ÅÑ[?Ôºü!ÔºÅ.]*$/s, "$1„Åß„Çã„ÅÆ„ÅäÂâç„Å†„Åë")
        .replace(/^„Åø„Çì„Å™(?:\s*)(.*)(?:\s*)„Å¶„Å∏„Çì[?Ôºü!ÔºÅ.]*$/s, "$1„Å¶„Çì„ÅÆ„ÅäÂâç„Å†„Åë")
        .replace(/^„Åø„Çì„Å™(?:\s*)(.*)(?:\s*)„Åß„Å∏„Çì[?Ôºü!ÔºÅ.]*$/s, "$1„Åß„Çì„ÅÆ„ÅäÂâç„Å†„Åë");
    return JSONResponse(createReplyWithTags(env, mention, content, tags))
}

async function doNullpoGa(request: Request, env: Env): Promise<Response> {
    if (!bearerAuthentication(request, env.NULLPOGA_GA_TOKEN)) {
        return notAuthenticated(request, env);
    }
    const mention: Event = await request.json();
    let content = "" + mention.content;
    if (
        !content.match(/^„Å¨[„Å¨„Çã„ÅΩ„Å£„Éº\n]+$/) || !content.match(/„Çã/) ||
        !content.match(/„ÅΩ/)
    ) {
        return JSONResponse(null);
    }
    content = content.replaceAll("„Å¨", "ÔΩ∂Ôæû").replaceAll("„Çã", "ÔΩØ").replaceAll(
        "„ÅΩ„Å£",
        "ÔΩ∂ÔæûÔΩØ",
    ).replaceAll("„Éº„ÅΩ", "ÔΩ∞ÔΩ∂ÔæûÔΩØ").replaceAll("„Éº", "ÔΩ∞").replaceAll("„Å£", "ÔΩØ")
        .replaceAll(/ÔΩØ+/g, "ÔΩØ").replaceAll("„ÅΩ", "");
    return JSONResponse(createReplyWithTags(env, mention, content, []))
}

async function doTsurupoVa(request: Request, env: Env): Promise<Response> {
    if (!bearerAuthentication(request, env.NULLPOGA_VA_TOKEN)) {
        return notAuthenticated(request, env);
    }
    const mention: Event = await request.json();
    let content = "" + mention.content;
    if (
        !content.match(/^„Å§[„Å§„Çã„ÅΩ„Å£„Éº\n]+$/) || !content.match(/„Çã/) ||
        !content.match(/„ÅΩ/)
    ) {
        return JSONResponse(null);
    }
    content = content.replaceAll("„Å§", "ÔΩ≥ÔæûÔΩß").replaceAll("„Çã", "ÔΩØ").replaceAll(
        "„ÅΩ„Å£",
        "ÔΩ≥ÔæûÔΩßÔΩØ",
    ).replaceAll("„Éº„ÅΩ", "ÔΩ∞ÔΩ≥ÔæûÔΩßÔΩØ").replaceAll("„Éº", "ÔΩ∞").replaceAll("„Å£", "ÔΩØ")
        .replaceAll(/ÔΩØ+/g, "ÔΩØ").replaceAll("„ÅΩ", "");
    return JSONResponse(createReplyWithTags(env, mention, content, []))
}

async function doNattoruyarogai(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    let content = "" + mention.content;
    if (!content.match(/„Åù„ÅÜ„ÅØ„Å™„Çâ„Çì„ÇÑ„Çç/)) {
        return JSONResponse(null);
    }
    return JSONResponse(createReplyWithTags(env, mention, "„Å™„Å£„Å®„Çã„ÇÑ„Çç„Åå„ÅÑ!!", []))
}

const pai = "üÄÄüÄÅüÄÇüÄÉüÄÑüÄÖüÄÜüÄáüÄàüÄâüÄäüÄãüÄåüÄçüÄéüÄèüÄêüÄëüÄíüÄìüÄîüÄïüÄñüÄóüÄòüÄôüÄöüÄõüÄúüÄùüÄûüÄüüÄ†üÄ°'";
//const pai = 'Êù±ÂçóË•øÂåóÁôΩÁô∫‰∏≠‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÔºëÔºíÔºìÔºîÔºïÔºñÔºóÔºòÔºô‚ë†‚ë°‚ë¢‚ë£‚ë§‚ë•‚ë¶‚ëß‚ë®'

async function doMahjongPai(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const content = Array.from(pai.repeat(4))
        .map((v) => ({ v, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort).map(({ v }) => v)
        .slice(0, 14).sort().join("");
    return JSONResponse(createReplyWithTags(env, mention, content, []))
}

async function doSuddendeanth(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");
    return JSONResponse(
        createReplyWithTags(
            env,
            mention,
            suddendeath(mention.content, true),
            tags,
        ),
    )
}

async function doLoginbonus(request: Request, env: Env): Promise<Response> {
    if (!bearerAuthentication(request, env.NULLPOGA_LOGINBONUS_TOKEN)) {
        return notAuthenticated(request, env);
    }
    const mention: Event = await request.json();
    return JSONResponse(createReplyWithTags(env, mention, "„ÅÇ„Çä„Åæ„Åõ„Çì", []))
}

async function doNagashite(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const m = mention.content.match(/ÊµÅ„Åó„Å¶(\s+.*)$/);
    const wave = m ? m[1].trim() : "üåäüåäüåäüåäüåäüåäüåäüåä'";
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");
    return JSONResponse(createNoteWithTags(env, mention, (wave + "\n").repeat(12), tags))
}

let lokuyowImages: any[] = [];

async function doLokuyow(request: Request, env: Env): Promise<Response> {
    if (lokuyowImages.length === 0) {
        lokuyowImages = await fetch("https://lokuyow.github.io/images.json").then(
            (resp) => resp.json()
        );
    }
    const item = "#„É≠„ÇØ„É®„Ç¶ÁîªÂÉè\n" +
        "https://raw.githubusercontent.com/Lokuyow/Lokuyow.github.io/main/" +
        lokuyowImages[Math.floor(Math.random() * lokuyowImages.length)].src;
    const mention: Event = await request.json();
    const tags = [["t", "„É≠„ÇØ„É®„Ç¶ÁîªÂÉè"]];
    return JSONResponse(createReplyWithTags(env, mention, item, tags))
}

let shioImages: any[] = [];

async function doUpdate(_request: Request, _env: Env): Promise<Response> {
    shioImages = [];
    lokuyowImages = [];
    return JSONResponse({ "status": "OK" })
}

async function doShio(request: Request, env: Env): Promise<Response> {
    if (shioImages.length === 0) {
        shioImages = await fetch(
            "https://gist.githubusercontent.com/mattn/7bfa7895e3ee521dff9b24879081dad9/raw/shio.json",
        ).then((resp) => resp.json());
    }
    const mention: Event = await request.json();
    const arg = mention.content.split(/\s+/)[1] || "";
    const index = arg
        ? Number(arg) - 1
        : Math.floor(Math.random() * shioImages.length);
    const item = "#„Åó„ÅäÁîªÂÉè\n" + shioImages[index % shioImages.length].src;
    const tags = [["t", "„Åó„ÅäÁîªÂÉè"]];
    return JSONResponse(createReplyWithTags(env, mention, item, tags))
}

function levenshtein(a: string, b: string): number {
    const an = a ? a.length : 0;
    const bn = b ? b.length : 0;
    if (an === 0) return bn;
    if (bn === 0) return an;
    const matrix = new Array<number[]>(bn + 1);
    for (let i = 0; i <= bn; ++i) {
        let row = matrix[i] = new Array<number>(an + 1);
        row[0] = i;
    }
    const firstRow = matrix[0];
    for (let j = 1; j <= an; ++j) {
        firstRow[j] = j;
    }
    for (let i = 1; i <= bn; ++i) {
        for (let j = 1; j <= an; ++j) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1],
                    matrix[i][j - 1],
                    matrix[i - 1][j],
                ) + 1;
            }
        }
    }
    return matrix[bn][an];
}

async function doDistance(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    let content = "" + mention.content;
    let m = content.match(/^"(\S+)"„Å®"(\S+)"„ÅÆÊñáÂ≠óÂàóË∑ùÈõ¢$/);
    if (!m) m = content.match(/^„Äå(\S+)„Äç„Å®„Äå(\S+)„Äç„ÅÆÊñáÂ≠óÂàóË∑ùÈõ¢$/);
    if (!m) m = content.match(/^(\S+)\s*„Å®\s*(\S+)\s*„ÅÆÊñáÂ≠óÂàóË∑ùÈõ¢$/);
    if (!m) return JSONResponse(null);
    return JSONResponse(createReplyWithTags(env, mention, `${levenshtein(m[1], m[2])}„Åß„Åô`, []));
}

async function doOppai(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    return JSONResponse(createLike(env, mention))
}

async function doPe(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    return JSONResponse(createNoteWithTags(env, mention, "„Å∫„Åá„Äú", []))
}

async function doNya(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    let content = [" AÔºøÔºøA", "|„Éª„ÖÖ„Éª |", "|„Å£„ÄÄÔΩÉ|", ""].join("\n");
    let arr = mention.content.replace(/„Å´„ÇÉÔºÅ$/, "").split(/(:[^:]+:)/g).map(
        (x: string) => {
            if (/^(:[^:]+:)$/.test(x)) return [x];
            //return [...x.replace(/[A-Za-z0-9]/g, (s) => String.fromCharCode(s.charCodeAt(0) + 0xFEE0)).replace(/[„Éº„Äú]/g, 'ÔΩú')]
            return runes(
                x.replace(
                    /[A-Za-z0-9]/g,
                    (s) => String.fromCharCode(s.charCodeAt(0) + 0xFEE0),
                ).replace(/[„Éº„Äú]/g, "ÔΩú"),
            );
        },
    ).flat();
    for (const c of arr) {
        if (c === "" || c === "\n" || c === "\t" || c === " ") continue;
        const isW = ["F", "W", "A", "N"].includes(eaw.eastAsianWidth(c));
        content += "|„ÄÄ" + (isW ? c : c + " ") + "„ÄÄ|\n";
    }
    content += [" UÔø£Ôø£U"].join("\n");
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");
    return JSONResponse(createReplyWithTags(env, mention, content, tags))
}

async function doGrave(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const content = mention.content.trim();
    if (!content.match(/.„ÅÆÂ¢ì$/)) {
        return JSONResponse(null);
    }
    let result = ["„ÄÄ ÔºøÔºø_", "„ÄÄ |Ôºº „ÄÄÔºº", "„ÄÄ |   |Ôø£   ÔΩú", ""].join("\n");

    let arr = content.replace(/„ÅÆÂ¢ì$/, "").split(/(:[^:]+:)/g).map(
        (x: string) => {
            if (/^(:[^:]+:)$/.test(x)) return [x];
            //return [...x.replace(/[A-Za-z0-9]/g, (s) => String.fromCharCode(s.charCodeAt(0) + 0xFEE0)).replace(/[„Éº„Äú]/g, 'ÔΩú')]
            return runes(
                x.replace(
                    /[A-Za-z0-9]/g,
                    (s) => String.fromCharCode(s.charCodeAt(0) + 0xFEE0),
                ).replace(/[„Éº„Äú]/g, "ÔΩú"),
            );
        },
    ).flat();
    for (const c of arr) {
        if (c === "" || c === "\n" || c === "\t" || c === " ") continue;
        const isW = ["F", "W", "A", "N"].includes(eaw.eastAsianWidth(c));
        result += "„ÄÄ |   |  " + (isW ? c : c + " ") + " ÔΩú\n";
    }
    result += [
        "„ÄÄ |   |  „ÅÆ ÔΩú",
        " Ôºø|   |  Â¢ì ÔΩú",
        "|ÔººÔºº|ÔºøÔºø‰∫ÖÔºº",
        " ÔººÂåö‰∫å ÀòœâÀò  ‰∫å]",
    ].join("\n");
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");
    return JSONResponse(createReplyWithTags(env, mention, result, tags))
}

async function doFumofumo(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const content = "https://image.nostr.build/f8b39a30c03aa0fafdd74f7f6be3956696f4546ced43c28b0a6103c6ff3a3478.jpg"
    return JSONResponse(createReplyWithTags(env, mention, content, []))
}

async function doOchinchinLand(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");

    let content = "";
    if (mention.content.match(/[?Ôºü]$/)) {
        const status = (await env.ochinchinland.get("status")) as string;
        content = status === "open" ? "ÈñãÂúí‰∏≠" : "ÈñâÂúí‰∏≠";
    } else if (mention.content.match(/ÈñãÈñâ[!ÔºÅ]*$/)) {
        await env.ochinchinland.put("status", "close");
        content =
            "https://cdn.nostr.build/i/f6103329b41603af2b36ec0131d27dd39d28ca1ddeb0041cd2839e5954563a92.jpg";
    } else if (mention.content.match(/ÈñâÂúí[!ÔºÅ]*$/)) {
        await env.ochinchinland.put("status", "close");
        content =
            "https://cdn.nostr.build/i/4a7963a07bdac34b1408b871548d3a06527af359ad5a9f080d3c2031f6e582fe.jpg";
    } else if (mention.content.match(/ÈñãÂúí[!ÔºÅ]*$/)) {
        await env.ochinchinland.put("status", "open");
        content =
            "https://cdn.nostr.build/i/662dab3ac355c5b2e8682f10eef4102342599bf8f77b52e9c7a7a52153398bfd.jpg";
    } else {
        return JSONResponse(null);
    }
    return JSONResponse(createReplyWithTags(env, mention, content, tags))
}

async function doWakaru(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");
    const content = mention.content.trim().match(/^[„ÇèÂàÜ]„Åã„Çã[!ÔºÅ]*$/)
        ? "https://cdn.nostr.build/i/f795a1ba2802c5b397cb538d0068da2deb6e7510d8cfff877e5561a15d55199b.jpg"
        : "https://cdn.nostr.build/i/fd99d078ba96f85b5e3f754e1aeef5f42dbf3312b5a345c5f3ea6405ce2980a7.jpg";
    return JSONResponse(createReplyWithTags(env, mention, content, tags))
}

const hakatano = new Map([
    ["Ë£∏„Å´", "„Åó„Çç"],
    ["„ÅØ„Å†„Åã„Å´", "„Åó„Çç"],
    ["„Åü„Åã„Å™„Çè", "„Ç≤„Éº„Éà„Ç¶„Çß„Ç§"],
    ["„Åü„Åã„Å†„ÅÆ", "„Å∞„Å∞"],
    ["„Åï„Åã„Åü„Å®", "„Åó„Åä"],
    ["„Åã„Åë„ÅÑ„Å®", "„Åó„Åä"],
    ["„ÇÇ„Çä„ÇÇ„Å®", "„Çå„Åä"],
    ["„Å®„Åø„Éº„Åö", "„Åæ„Åï"],
    ["„Åä„Åã„ÇÇ„Å®", "„Åæ„Çà"],
    ["„Åæ„Å§„ÇÇ„Å®", "„ÅÑ„Çà"],
    ["„Åø„Çè„ÅÇ„Åç", "„Å≤„Çç"],
    ["„ÅÇ„Åü„Åü„Åü", "„Åü„Åü"],
    ["„ÅØ„ÇÑ„Åó„Çâ", "„ÅÑ„Åô"],
    ["„ÅÇ„Çã„Åã„ÅÆ", "„ÅÑ„Å©"],
    ["„ÅØ„Åå„Åü„Çí", "„Åø„Çç"],
    ["„ÅØ„Åã„Åü„ÅÆ", "„Åó„Åä"],
]);

async function doHakatano(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");
    const content = mention.content.replace(/„Å£/g, "").replace(/[!ÔºÅ]/g, "")
        .trim();
    for (const [k, v] of hakatano) {
        if (content === k) {
            return JSONResponse(createReplyWithTags(env, mention, v, tags))
        }
    }
    return JSONResponse(null);
}

async function doSUUMO(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const content =
        "üåö„ÉÄ„É≥üí•„ÉÄ„É≥üí•„ÉÄ„É≥üí•„Ç∑„É£„Éº„É≥üé∂„ÅΩ„Çèüåù„ÅΩ„Çèüåö„ÅΩ„Çèüåù„ÅΩ„Çèüåö„ÅΩ„Çèüåù„ÅΩ„Çèüåö„ÅΩ„Äú„Äú„Äú„Çè‚§¥„ÅΩ„Çèüåö„ÅΩ„Çèüåù„ÅΩ„Çèüåö„ÅΩ„Çèüåù„ÅΩ„Çèüåö„ÅΩ„Çèüåù„ÅΩÔΩûÔΩûÔΩû„Çè‚§µüåû'";
    return JSONResponse(createNoteWithTags(env, mention, content, []))
}

async function doCAT(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    if (mention.pubkey === NULLPOGA_NPUB) return JSONResponse(null);
    let res = await fetch("https://api.thecatapi.com/v1/images/search");
    const images: { [name: string]: any } = await res.json();
    const tags = [["t", "„Å¨„Å£„ÅìÁîªÂÉè"]];
    return JSONResponse(createReplyWithTags(env, mention, `#„Å¨„Å£„ÅìÁîªÂÉè\n${images[0].url}`, tags))
}

async function doDOG(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    if (mention.pubkey === NULLPOGA_NPUB) return JSONResponse(null);
    let res = await fetch("https://api.thedogapi.com/v1/images/search");
    const images: { [name: string]: any } = await res.json();
    const tags = [["t", "„ÅÑ„Å£„Å¨ÁîªÂÉè"]];
    return JSONResponse(createReplyWithTags(env, mention, `#„ÅÑ„Å£„Å¨ÁîªÂÉè\n${images[0].url}`, tags))
}

async function doTranslate(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const m = mention.content.match(/(ÂíåËã±|Ëã±Âíå)\s+(.+)$/) || [];
    const content = m ? m[2] : "";
    const ai = new Ai(env.AI);
    const inputs = {
        text: content,
        source_lang: "en",
        target_lang: "ja",
    };
    switch (m[1]) {
        case "Ëã±Âíå":
            inputs.source_lang = "en";
            inputs.target_lang = "ja";
            break;
        case "ÂíåËã±":
            inputs.source_lang = "ja";
            inputs.target_lang = "en";
            break;
    }
    const response = await ai.run("@cf/meta/m2m100-1.2b", inputs);
    const tags = mention.tags.filter((x: any[]) => x[0] === "emoji");
    return JSONResponse(createReplyWithTags(env, mention, response.translated_text, tags))
}

async function doMetadata(request: Request, env: Env): Promise<Response> {
    const metadata: Event = await request.json();
    const tags = metadata.tags.filter((x: any[]) => x[0] === "emoji");
    const profile: { [name: string]: any } = JSON.parse(metadata.content);
    const content = `${profile["display_name"].trim()
        } „Åï„Çì„Åå„Éó„É≠„Éï„Ç£„Éº„É´„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü`;
    metadata.kind = 1;
    return JSONResponse(createNoteWithTags(env, metadata, content, tags))
}

export interface Rate {
    pair: string;
    time: string;
    rate: string;
}

async function doBtcHow(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const url = "https://coincheck.com/ja/exchange/rates/search?pair=btc_jpy&time=" + new Date().toISOString()
    const res = await fetch(url);
    if (res.ok) {
        return JSONResponse(createReplyWithTags(env, mention, `ÁèæÂú®„ÅÆ„Éì„ÉÉ„Éà„Ç≥„Ç§„É≥Êó•Êú¨ÂÜÜÂª∫„Å¶„Åß ${(await res.json() as Rate).rate} ÂÜÜ„Åß„Åô`, []))
    }
    return JSONResponse(createNoteWithTags(env, mention, "", []))
}

export interface Quotes {
    quotes: {
        high: string;
        open: string;
        bid: string;
        currencyPairCode: string;
        ask: string;
        low: string;
    }[]
}

async function doJpyHow(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    const url = "https://www.gaitameonline.com/rateaj/getrate"
    const res = await fetch(url);
    if (res.ok) {
        const usdjpy: string = (await res.json() as Quotes).quotes.filter((x) => x?.currencyPairCode === "USDJPY")[0].bid || '?';
        return JSONResponse(createReplyWithTags(env, mention, `ÁèæÂú®„ÅÆÂÜÜÁõ∏Â†¥„ÅØ1„Éâ„É´ ${usdjpy} ÂÜÜ„Åß„Åô`, []))
    }
    return JSONResponse(createNoteWithTags(env, mention, "", []))
}

async function doSleeply(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    return JSONResponse(createReplyWithTags(env, mention, "(`ÔΩ•–¥ÔΩ•‚äÇÂΩ°‚òÜ))–î¬¥)) ÔæäÔæüÔΩßÔæù", []))
}

async function doHit(request: Request, env: Env): Promise<Response> {
    const mention: Event = await request.json();
    return JSONResponse(createNoteWithTags(env, mention, "(`ÔΩ•–¥ÔΩ•‚äÇÂΩ°‚òÜ))–î¬¥)) ÔæäÔæüÔΩßÔæù", []));
}

export default {
    async fetch(
        request: Request,
        env: Env,
    ): Promise<Response> {
        const { protocol, pathname } = new URL(request.url);
        const pathArray = pathname.split("/");

        if (
            "https:" !== protocol ||
            "https" !== request.headers.get("x-forwarded-proto")
        ) {
            throw new Error("Please use a HTTPS connection.");
        }

        console.log(`${request.method}: ${request.url} `);

        if (request.method === "GET") {
            switch (pathArray[1]) {
                case "nullpo":
                    return doNullpo(request, env);
                case "ochinchinland":
                    return doOchinchinLandStatus(request, env);
                case "clock":
                    return doClock(request, env);
                case "update":
                    return doUpdate(request, env);
                case "relationship":
                    return doRelationsihp(request, env);
                case "":
                    return doPage(request, env);
            }
            return notFound(request, env);
        }
        if (request.method === "POST") {
            switch (pathArray[1]) {
                case "loginbonus":
                    return doLoginbonus(request, env);
                case "lokuyow":
                    return doLokuyow(request, env);
                case "shio":
                    return doShio(request, env);
                case "tsurupo":
                    return doTsurupoVa(request, env);
                case "nagashite":
                    return doNagashite(request, env);
                case "nattoruyarogai":
                    return doNattoruyarogai(request, env);
                case "suddendeath":
                    return doSuddendeanth(request, env);
                case "mahjongpai":
                    return doMahjongPai(request, env);
                case "onlyyou":
                    return doOnlyYou(request, env);
                case "suitou":
                    return doSuitou(request, env);
                case "igyo":
                    return doIgyo(request, env);
                case "letterpack":
                    return doLetterpack(request, env);
                case "ultrasoul":
                    return doUltrasoul(request, env);
                case "hi":
                    return doHi(request, env);
                case "angel":
                    return doAngel(request, env);
                case "where":
                    return doWhere(request, env);
                case "google":
                    return doGoogle(request, env);
                case "distance":
                    return doDistance(request, env);
                case "oppai":
                    return doOppai(request, env);
                case "pe":
                    return doPe(request, env);
                case "nya":
                    return doNya(request, env);
                case "grave":
                    return doGrave(request, env);
                case "ochinchinland":
                    return doOchinchinLand(request, env);
                case "fumofumo":
                    return doFumofumo(request, env);
                case "wakaru":
                    return doWakaru(request, env);
                case "hakatano":
                    return doHakatano(request, env);
                case "suumo":
                    return doSUUMO(request, env);
                case "cat":
                    return doCAT(request, env);
                case "dog":
                    return doDOG(request, env);
                case "nemui":
                    return doSleeply(request, env);
                case "hit":
                    return doHit(request, env);
                case "translate":
                    return doTranslate(request, env);
                case "metadata":
                    return doMetadata(request, env);
                case "btchow":
                    return doBtcHow(request, env);
                case "jpyhow":
                    return doJpyHow(request, env);
                case "":
                    return doNullpoGa(request, env);
            }
            return notFound(request, env);
        }

        return unsupportedMethod(request, env);
    },
};
